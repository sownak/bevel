##############################################################################################
#  Copyright Accenture. All Rights Reserved.
#
#  SPDX-License-Identifier: Apache-2.0
##############################################################################################

apiVersion: batch/v1
kind: Job
metadata:
  name: "{{ $.Values.metadata.name }}"
  namespace: "{{ $.Values.metadata.namespace }}"
  labels:
    app.kubernetes.io/name: "{{ $.Values.metadata.name }}"
    helm.sh/chart: {{ .Chart.Name }}-{{ .Chart.Version | replace "+" "_" }}
    app.kubernetes.io/managed-by: {{ .Release.Service }}
    app.kubernetes.io/instance: {{ .Release.Name }}
    {{- if $.Values.labels }}
    {{- range $key, $value := $.Values.labels.deployment }}
    {{- range $k, $v := $value }}
    {{ $k }}: {{ $v | quote }}
    {{- end }}
    {{- end }}
    {{- end }}
spec:
  backoffLimit: 6
  template:
    metadata:
      labels:
        app: "{{ $.Values.metadata.name }}"
        app.kubernetes.io/name: "{{ $.Values.metadata.name }}"
        helm.sh/chart: {{ .Chart.Name }}-{{ .Chart.Version | replace "+" "_" }}
        app.kubernetes.io/managed-by: {{ .Release.Service }}
        app.kubernetes.io/instance: {{ .Release.Name }} 
        {{- if $.Values.labels }}
        {{- range $key, $value := $.Values.labels.deployment }}
        {{- range $k, $v := $value }}
        {{ $k }}: {{ $v | quote }}
        {{- end }}
        {{- end }}
        {{- end }}
    spec:
      securityContext:
        runAsUser: 1000
        runAsGroup: 3000
        fsGroup: 3000
      restartPolicy: OnFailure
      imagePullSecrets:
        - name: "{{ $.Values.image.pullSecret }}"
      serviceAccountName: {{ $.Values.vault.serviceaccountname }}
      volumes:
        - name: node-crypto
          emptyDir:
            medium: Memory
      initContainers:
      - name: init-check-crypto
        image: "{{ $.Values.image.alpineutils }}"
        imagePullPolicy: "{{ $.Values.image.pullPolicy }}"
        env:
        - name: VAULT_ADDR
          value: {{ $.Values.vault.address }}
        - name: VAULT_SECRET_ENGINE
          value: {{ $.Values.vault.secretengine }}
        command: ["sh", "-c"]
        args:
        - |-
          validateVaultResponse () {
            if echo ${2} | grep "errors"; then
              echo "ERROR: unable to retrieve ${1}: ${2}"
              exit 1
            fi
            if  [ "$3" == "LOOKUPSECRETRESPONSE" ]
            then
              http_code=$(curl -sS -o /dev/null -w "%{http_code}" \
              --header "X-Vault-Token: ${VAULT_CLIENT_TOKEN}" \
              ${VAULT_ADDR}/v1/${vault_secret_key})
              curl_response=$?
              if test "$http_code" != "200" ; then
                  echo "Http response code from Vault - $http_code"
                  if test "$curl_response" != "0"; then
                    echo "Error: curl command failed with error code - $curl_response"
                    exit 1
                  fi
              fi
            fi
          }
          KUBE_SA_TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
          echo "Getting client token from Vault Server: ${VAULT_ADDR}"
          # Login to Vault and so I can get an approle token
          VAULT_CLIENT_TOKEN=$(curl -sS --request POST ${VAULT_ADDR}/v1/auth/${KUBERNETES_AUTH_PATH}/login \
            -H "Content-Type: application/json" \
            -d '{"role":"'"${VAULT_APP_ROLE}"'","jwt":"'"${KUBE_SA_TOKEN}"'"}' | \
            jq -r 'if .errors then . else .auth.client_token end')
          validateVaultResponse 'vault login token' "${VAULT_CLIENT_TOKEN}"

          CRYPTO_PATH=/crypto
          
          {{- range .Values.organisation.nodes }}
            mkdir ${CRYPTO_PATH}/{{ .name }}

            VAULT_PATH_NODE_CRYPTO=data/{{ $.Values.metadata.namespace }}/crypto/{{ .name }}/data

            # Check for node crypto ..
            LOOKUP_SECRET_RESPONSE=$(curl -sS --header "X-Vault-Token: ${VAULT_CLIENT_TOKEN}" ${VAULT_ADDR}/v1/${VAULT_SECRET_ENGINE}/${VAULT_PATH_NODE_CRYPTO} | jq -r 'if .errors then . else . end')
            
            NODE_KEY=$(echo ${LOOKUP_SECRET_RESPONSE} | jq -r '.data.data["key"]' 2>&1)

            for field in "$NODE_KEY"
            do
              if [ "$field" = "null"  ] || [[ "$field" = "parse error"* ]] || [ "$field" = "" ]
              then
                echo "data absent in ${VAULT_PATH_NODE_CRYPTO}"
                touch ${CRYPTO_PATH}/{{ .name }}/node_crypto_absent
              else
                echo "data present in ${VAULT_PATH_NODE_CRYPTO}"
              fi
            done
          {{- end }}
          echo "Done checking for crypto in vault"
        volumeMounts:
          - name: node-crypto
            mountPath: /crypto    
      containers:
        - name:  "generate-node-keys"
          image: "{{ $.Values.image.besucontainer }}"
          env:
          - name: VAULT_ADDR
            value: {{ $.Values.vault.address }}
          imagePullPolicy: IfNotPresent
          command: ["sh", "-c"]
          args:
            - |-
              echo "Generating keypair and nodeAddress.."
              CRYPTO_PATH=/crypto
              {{- range .Values.organisation.nodes }}
                  if [ -f ${CRYPTO_PATH}/{{ .name }}/node_crypto_absent ]
                  then
                    mkdir ${CRYPTO_PATH}/{{ .name }}/data
                    echo "Generating keypair and nodeAddress for {{ .name }}.."
                    besu --data-path ${CRYPTO_PATH}/{{ .name }}/data public-key export-address --to ${CRYPTO_PATH}/{{ .name }}/data/nodeAddress
                    besu --data-path ${CRYPTO_PATH}/{{ .name }}/data public-key export --to ${CRYPTO_PATH}/{{ .name }}/data/key.pub
                  else
                    echo "keypair and nodeAddress for {{ .name }} already present in vault.."
                  fi
              {{- end }}
              touch ${CRYPTO_PATH}/generate_node_keys_complete
          volumeMounts:
           - name: node-crypto
             mountPath: /crypto
        - name:  "store-node-keys"
          image: "{{ $.Values.image.alpineutils }}"
          imagePullPolicy: IfNotPresent
          env:
          - name: VAULT_ADDR
            value: {{ $.Values.vault.address }}
          - name: VAULT_SECRET_ENGINE
            value: {{ $.Values.vault.secretengine }}
          - name: KUBERNETES_AUTH_PATH
            value: {{ $.Values.vault.authpath }}
          - name: VAULT_APP_ROLE
            value: {{ $.Values.vault.role }}
          - name: MOUNT_PATH
            value: "/crypto"
          command: ["sh", "-c"]
          args:
            - |-
              echo "Work on mount path.."
              cd ${MOUNT_PATH}
              
              validateVaultResponse () {
                if echo ${2} | grep "errors"; then
                  echo "ERROR: unable to retrieve ${1}: ${2}"
                  exit 1
                fi
                if  [ "$3" == "LOOKUPSECRETRESPONSE" ]
                then
                  http_code=$(curl -sS -o /dev/null -w "%{http_code}" \
                  --header "X-Vault-Token: ${VAULT_CLIENT_TOKEN}" \
                  ${VAULT_ADDR}/v1/${vault_secret_key})
                  curl_response=$?
                  if test "$http_code" != "200" ; then
                      echo "Http response code from Vault - $http_code"
                      if test "$curl_response" != "0"; then
                        echo "Error: curl command failed with error code - $curl_response"
                        exit 1
                      fi
                  fi
                fi
              }
              KUBE_SA_TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
              
              echo "Getting client token from: ${VAULT_ADDR}"
              Login to Vault and so I can get an approle token
              VAULT_CLIENT_TOKEN=$(curl -sS --request POST ${VAULT_ADDR}/v1/auth/${KUBERNETES_AUTH_PATH}/login \
                -H "Content-Type: application/json" \
                -d '{"role":"'"${VAULT_APP_ROLE}"'","jwt":"'"${KUBE_SA_TOKEN}"'"}' | \
                jq -r 'if .errors then . else .auth.client_token end')
              validateVaultResponse 'vault login token' "${VAULT_CLIENT_TOKEN}"

              while ! [ -f ${MOUNT_PATH}/generate_node_keys_complete ]
              do
                echo 'Waiting for node keys..'
                sleep 2s
              done

              CRYPTO_PATH=${MOUNT_PATH}

              {{- range .Values.organisation.nodes }}
              COUNTER=1
              while [ "$COUNTER" -le {{ $.Values.healthcheck.retries }} ]
              do
                if [ -f ${CRYPTO_PATH}/{{ .name }}/node_crypto_absent ]
                then
                  NODE_ADDRESS=$(cat ${CRYPTO_PATH}/{{ .name }}/data/nodeAddress)
                  NODE_KEY=$(cat ${CRYPTO_PATH}/{{ .name }}/data/key)
                  NODE_KEY_PUB=$(cat ${CRYPTO_PATH}/{{ .name }}/data/key.pub)

                  # create the payload for node crypto
                  echo "
                  {
                    \"data\":
                      {
                        \"nodeAddress\": \"${NODE_ADDRESS}\",
                        \"key\": \"${NODE_KEY}\",
                        \"key_pub\": \"${NODE_KEY_PUB}\"
                      }
                  }" > payload.json

                  # create the vault path for node cryto
                  VAULT_PATH_NODE_CRYPTO=data/{{ $.Values.metadata.namespace }}/crypto/{{ .name }}/data
                  
                  # This command copy the tls certificates to the Vault
                    curl \
                      -H "X-Vault-Token: ${VAULT_CLIENT_TOKEN}" \
                      -H "Content-Type: application/json" \
                      -X POST \
                      -d @payload.json \
                      ${VAULT_ADDR}/v1/${VAULT_SECRET_ENGINE}/${VAULT_PATH_NODE_CRYPTO}
                  
                  # Check for node crypto ..
                  LOOKUP_SECRET_RESPONSE=$(curl -sS --header "X-Vault-Token: ${VAULT_CLIENT_TOKEN}" ${VAULT_ADDR}/v1/${VAULT_SECRET_ENGINE}/${VAULT_PATH_NODE_CRYPTO} | jq -r 'if .errors then . else . end')
                  
                  NODE_KEY=$(echo ${LOOKUP_SECRET_RESPONSE} | jq -r '.data.data["key"]' 2>&1)

                  for field in "$NODE_KEY"
                  do
                    if [ "$field" = "null"  ] || [[ "$field" = "parse error"* ]] || [ "$field" = "" ]
                    then
                      NODE_CRYPTO_WRITTEN=false
                      break
                    else
                      NODE_CRYPTO_WRITTEN=true
                    fi
                  done
                  rm payload.json
                  if [ "$NODE_CRYPTO_WRITTEN" = "true" ]
                  then
                    echo "Success: store crypto for {{ .name }}"
                    break
                  else
                    echo "Crypto materials are not ready, sleeping for {{ $.Values.healthcheck.sleepTimeAfterError }} - $COUNTER "
                    sleep {{ $.Values.healthcheck.sleepTimeAfterError }}
                    COUNTER=`expr "$COUNTER" + 1`
                  fi
                else
                  echo "Skipped: store cryto for {{ .name }}"
                  break
                fi
              done
              if [ "$COUNTER" -gt {{ $.Values.healthcheck.retries }} ]
              then
                echo "Retry attempted `expr $COUNTER - 1` times, Crypto materials have not been saved."
                exit 1
              fi
              {{- end }}
          volumeMounts:
            - name: node-crypto
              mountPath: /crypto
